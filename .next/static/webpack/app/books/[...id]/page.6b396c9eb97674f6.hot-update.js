"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/books/[...id]/page",{

/***/ "(app-pages-browser)/./lib/openLibrary.ts":
/*!****************************!*\
  !*** ./lib/openLibrary.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenLibraryAPI: function() { return /* binding */ OpenLibraryAPI; },\n/* harmony export */   debounce: function() { return /* binding */ debounce; }\n/* harmony export */ });\nconst OPEN_LIBRARY_BASE_URL = \"https://openlibrary.org\";\nconst COVERS_BASE_URL = \"https://covers.openlibrary.org/b\";\nclass OpenLibraryAPI {\n    static async searchBooks(query) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const searchParams = new URLSearchParams({\n            q: query,\n            limit: limit.toString(),\n            offset: offset.toString(),\n            fields: \"key,title,author_name,first_publish_year,isbn,cover_i,publisher,language,subject,ratings_average,ratings_count,want_to_read_count,currently_reading_count,already_read_count\"\n        });\n        const response = await fetch(\"\".concat(OPEN_LIBRARY_BASE_URL, \"/search.json?\").concat(searchParams));\n        if (!response.ok) {\n            throw new Error(\"Search failed: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    static async getBookDetails(bookKey) {\n        const response = await fetch(\"\".concat(OPEN_LIBRARY_BASE_URL).concat(bookKey, \".json\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch book details: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    static async getAuthorDetails(authorKey) {\n        const response = await fetch(\"\".concat(OPEN_LIBRARY_BASE_URL).concat(authorKey, \".json\"));\n        if (!response.ok) {\n            throw new Error(\"Failed to fetch author details: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    static getCoverUrl(coverId) {\n        let size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"M\";\n        return \"\".concat(COVERS_BASE_URL, \"/id/\").concat(coverId, \"-\").concat(size, \".jpg\");\n    }\n    static async searchByGenre(genre) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        return this.searchBooks('subject:\"'.concat(genre, '\"'), limit, offset);\n    }\n    static async searchByAuthor(author) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20, offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        return this.searchBooks('author:\"'.concat(author, '\"'), limit, offset);\n    }\n    static async searchByISBN(isbn) {\n        return this.searchBooks(\"isbn:\".concat(isbn), 1, 0);\n    }\n    static async getTrendingBooks() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 20;\n        // Use a search for popular books (this is a simplified approach)\n        return this.searchBooks(\"*\", limit, 0);\n    }\n    static async getPopularBooksByGenre(genre) {\n        let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 20;\n        // Search for popular books in genre, sorted by want-to-read count\n        const searchParams = new URLSearchParams({\n            q: 'subject:\"'.concat(genre, '\" AND has_fulltext:true'),\n            limit: limit.toString(),\n            offset: \"0\",\n            sort: \"want_to_read_count desc\",\n            fields: \"key,title,author_name,first_publish_year,isbn,cover_i,publisher,language,subject,ratings_average,ratings_count,want_to_read_count,currently_reading_count,already_read_count,edition_count\"\n        });\n        const response = await fetch(\"\".concat(OPEN_LIBRARY_BASE_URL, \"/search.json?\").concat(searchParams));\n        if (!response.ok) {\n            throw new Error(\"Search failed: \".concat(response.statusText));\n        }\n        return response.json();\n    }\n    static formatBookData(book) {\n        var _book_author_name, _book_isbn, _book_subject;\n        // Extract just the ID part from the key (e.g., \"/works/OL15601954W\" -> \"works/OL15601954W\")\n        const bookId = book.key.startsWith(\"/\") ? book.key.slice(1) : book.key;\n        return {\n            id: bookId,\n            title: book.title,\n            author: ((_book_author_name = book.author_name) === null || _book_author_name === void 0 ? void 0 : _book_author_name[0]) || \"Unknown Author\",\n            authors: book.author_name || [],\n            cover: book.cover_i ? this.getCoverUrl(book.cover_i) : \"/placeholder-book.svg\",\n            publishYear: book.first_publish_year,\n            isbn: (_book_isbn = book.isbn) === null || _book_isbn === void 0 ? void 0 : _book_isbn[0],\n            rating: book.ratings_average,\n            reviewCount: book.ratings_count,\n            subjects: ((_book_subject = book.subject) === null || _book_subject === void 0 ? void 0 : _book_subject.slice(0, 5)) || [],\n            publishers: book.publisher || [],\n            languages: book.language || [],\n            wantToReadCount: book.want_to_read_count,\n            currentlyReadingCount: book.currently_reading_count,\n            alreadyReadCount: book.already_read_count\n        };\n    }\n}\n// Helper function to debounce search requests\nfunction debounce(func, wait) {\n    let timeout;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        clearTimeout(timeout);\n        timeout = setTimeout(()=>func(...args), wait);\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFBOztRQUNUQyxhQUFhRjtRQUNiQSxVQUFVRyxXQUFXLElBQU1MLFFBQVFHLE9BQU9GO0lBQzVDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL29wZW5MaWJyYXJ5LnRzP2FhOWMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgT1BFTl9MSUJSQVJZX0JBU0VfVVJMID0gXCJodHRwczovL29wZW5saWJyYXJ5Lm9yZ1wiO1xyXG5jb25zdCBDT1ZFUlNfQkFTRV9VUkwgPSBcImh0dHBzOi8vY292ZXJzLm9wZW5saWJyYXJ5Lm9yZy9iXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE9wZW5MaWJyYXJ5Qm9vayB7XHJcbiAga2V5OiBzdHJpbmc7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBhdXRob3JfbmFtZT86IHN0cmluZ1tdO1xyXG4gIGZpcnN0X3B1Ymxpc2hfeWVhcj86IG51bWJlcjtcclxuICBpc2JuPzogc3RyaW5nW107XHJcbiAgY292ZXJfaT86IG51bWJlcjtcclxuICBwdWJsaXNoZXI/OiBzdHJpbmdbXTtcclxuICBsYW5ndWFnZT86IHN0cmluZ1tdO1xyXG4gIHN1YmplY3Q/OiBzdHJpbmdbXTtcclxuICByYXRpbmdzX2F2ZXJhZ2U/OiBudW1iZXI7XHJcbiAgcmF0aW5nc19jb3VudD86IG51bWJlcjtcclxuICB3YW50X3RvX3JlYWRfY291bnQ/OiBudW1iZXI7XHJcbiAgY3VycmVudGx5X3JlYWRpbmdfY291bnQ/OiBudW1iZXI7XHJcbiAgYWxyZWFkeV9yZWFkX2NvdW50PzogbnVtYmVyO1xyXG4gIGVkaXRpb25fY291bnQ/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQm9va1NlYXJjaFJlc3BvbnNlIHtcclxuICBudW1Gb3VuZDogbnVtYmVyO1xyXG4gIHN0YXJ0OiBudW1iZXI7XHJcbiAgZG9jczogT3BlbkxpYnJhcnlCb29rW107XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQm9va0RldGFpbHMge1xyXG4gIGtleTogc3RyaW5nO1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmcgfCB7IHZhbHVlOiBzdHJpbmcgfTtcclxuICBhdXRob3JzPzogQXJyYXk8eyBrZXk6IHN0cmluZyB9PjtcclxuICBzdWJqZWN0cz86IHN0cmluZ1tdO1xyXG4gIGNvdmVycz86IG51bWJlcltdO1xyXG4gIGlzYm5fMTA/OiBzdHJpbmdbXTtcclxuICBpc2JuXzEzPzogc3RyaW5nW107XHJcbiAgcHVibGlzaF9kYXRlPzogc3RyaW5nO1xyXG4gIHB1Ymxpc2hlcnM/OiBzdHJpbmdbXTtcclxuICBudW1iZXJfb2ZfcGFnZXM/OiBudW1iZXI7XHJcbiAgcGh5c2ljYWxfZm9ybWF0Pzogc3RyaW5nO1xyXG4gIHdvcmtzPzogQXJyYXk8eyBrZXk6IHN0cmluZyB9PjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE9wZW5MaWJyYXJ5QVBJIHtcclxuICBzdGF0aWMgYXN5bmMgc2VhcmNoQm9va3MoXHJcbiAgICBxdWVyeTogc3RyaW5nLFxyXG4gICAgbGltaXQ6IG51bWJlciA9IDIwLFxyXG4gICAgb2Zmc2V0OiBudW1iZXIgPSAwXHJcbiAgKTogUHJvbWlzZTxCb29rU2VhcmNoUmVzcG9uc2U+IHtcclxuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xyXG4gICAgICBxOiBxdWVyeSxcclxuICAgICAgbGltaXQ6IGxpbWl0LnRvU3RyaW5nKCksXHJcbiAgICAgIG9mZnNldDogb2Zmc2V0LnRvU3RyaW5nKCksXHJcbiAgICAgIGZpZWxkczpcclxuICAgICAgICBcImtleSx0aXRsZSxhdXRob3JfbmFtZSxmaXJzdF9wdWJsaXNoX3llYXIsaXNibixjb3Zlcl9pLHB1Ymxpc2hlcixsYW5ndWFnZSxzdWJqZWN0LHJhdGluZ3NfYXZlcmFnZSxyYXRpbmdzX2NvdW50LHdhbnRfdG9fcmVhZF9jb3VudCxjdXJyZW50bHlfcmVhZGluZ19jb3VudCxhbHJlYWR5X3JlYWRfY291bnRcIixcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXHJcbiAgICAgIGAke09QRU5fTElCUkFSWV9CQVNFX1VSTH0vc2VhcmNoLmpzb24/JHtzZWFyY2hQYXJhbXN9YFxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2VhcmNoIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXN5bmMgZ2V0Qm9va0RldGFpbHMoYm9va0tleTogc3RyaW5nKTogUHJvbWlzZTxCb29rRGV0YWlscz4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtPUEVOX0xJQlJBUllfQkFTRV9VUkx9JHtib29rS2V5fS5qc29uYCk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBib29rIGRldGFpbHM6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzeW5jIGdldEF1dGhvckRldGFpbHMoYXV0aG9yS2V5OiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7T1BFTl9MSUJSQVJZX0JBU0VfVVJMfSR7YXV0aG9yS2V5fS5qc29uYCk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBhdXRob3IgZGV0YWlsczogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgZ2V0Q292ZXJVcmwoY292ZXJJZDogbnVtYmVyLCBzaXplOiBcIlNcIiB8IFwiTVwiIHwgXCJMXCIgPSBcIk1cIik6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gYCR7Q09WRVJTX0JBU0VfVVJMfS9pZC8ke2NvdmVySWR9LSR7c2l6ZX0uanBnYDtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBhc3luYyBzZWFyY2hCeUdlbnJlKFxyXG4gICAgZ2VucmU6IHN0cmluZyxcclxuICAgIGxpbWl0OiBudW1iZXIgPSAyMCxcclxuICAgIG9mZnNldDogbnVtYmVyID0gMFxyXG4gICk6IFByb21pc2U8Qm9va1NlYXJjaFJlc3BvbnNlPiB7XHJcbiAgICByZXR1cm4gdGhpcy5zZWFyY2hCb29rcyhgc3ViamVjdDpcIiR7Z2VucmV9XCJgLCBsaW1pdCwgb2Zmc2V0KTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBhc3luYyBzZWFyY2hCeUF1dGhvcihcclxuICAgIGF1dGhvcjogc3RyaW5nLFxyXG4gICAgbGltaXQ6IG51bWJlciA9IDIwLFxyXG4gICAgb2Zmc2V0OiBudW1iZXIgPSAwXHJcbiAgKTogUHJvbWlzZTxCb29rU2VhcmNoUmVzcG9uc2U+IHtcclxuICAgIHJldHVybiB0aGlzLnNlYXJjaEJvb2tzKGBhdXRob3I6XCIke2F1dGhvcn1cImAsIGxpbWl0LCBvZmZzZXQpO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzeW5jIHNlYXJjaEJ5SVNCTihpc2JuOiBzdHJpbmcpOiBQcm9taXNlPEJvb2tTZWFyY2hSZXNwb25zZT4ge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoQm9va3MoYGlzYm46JHtpc2JufWAsIDEsIDApO1xyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzeW5jIGdldFRyZW5kaW5nQm9va3MoXHJcbiAgICBsaW1pdDogbnVtYmVyID0gMjBcclxuICApOiBQcm9taXNlPEJvb2tTZWFyY2hSZXNwb25zZT4ge1xyXG4gICAgLy8gVXNlIGEgc2VhcmNoIGZvciBwb3B1bGFyIGJvb2tzICh0aGlzIGlzIGEgc2ltcGxpZmllZCBhcHByb2FjaClcclxuICAgIHJldHVybiB0aGlzLnNlYXJjaEJvb2tzKFwiKlwiLCBsaW1pdCwgMCk7XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXN5bmMgZ2V0UG9wdWxhckJvb2tzQnlHZW5yZShcclxuICAgIGdlbnJlOiBzdHJpbmcsXHJcbiAgICBsaW1pdDogbnVtYmVyID0gMjBcclxuICApOiBQcm9taXNlPEJvb2tTZWFyY2hSZXNwb25zZT4ge1xyXG4gICAgLy8gU2VhcmNoIGZvciBwb3B1bGFyIGJvb2tzIGluIGdlbnJlLCBzb3J0ZWQgYnkgd2FudC10by1yZWFkIGNvdW50XHJcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcclxuICAgICAgcTogYHN1YmplY3Q6XCIke2dlbnJlfVwiIEFORCBoYXNfZnVsbHRleHQ6dHJ1ZWAsXHJcbiAgICAgIGxpbWl0OiBsaW1pdC50b1N0cmluZygpLFxyXG4gICAgICBvZmZzZXQ6IFwiMFwiLFxyXG4gICAgICBzb3J0OiBcIndhbnRfdG9fcmVhZF9jb3VudCBkZXNjXCIsXHJcbiAgICAgIGZpZWxkczpcclxuICAgICAgICBcImtleSx0aXRsZSxhdXRob3JfbmFtZSxmaXJzdF9wdWJsaXNoX3llYXIsaXNibixjb3Zlcl9pLHB1Ymxpc2hlcixsYW5ndWFnZSxzdWJqZWN0LHJhdGluZ3NfYXZlcmFnZSxyYXRpbmdzX2NvdW50LHdhbnRfdG9fcmVhZF9jb3VudCxjdXJyZW50bHlfcmVhZGluZ19jb3VudCxhbHJlYWR5X3JlYWRfY291bnQsZWRpdGlvbl9jb3VudFwiLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcclxuICAgICAgYCR7T1BFTl9MSUJSQVJZX0JBU0VfVVJMfS9zZWFyY2guanNvbj8ke3NlYXJjaFBhcmFtc31gXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZWFyY2ggZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9XHJcblxyXG4gIHN0YXRpYyBmb3JtYXRCb29rRGF0YShib29rOiBPcGVuTGlicmFyeUJvb2spIHtcclxuICAgIC8vIEV4dHJhY3QganVzdCB0aGUgSUQgcGFydCBmcm9tIHRoZSBrZXkgKGUuZy4sIFwiL3dvcmtzL09MMTU2MDE5NTRXXCIgLT4gXCJ3b3Jrcy9PTDE1NjAxOTU0V1wiKVxyXG4gICAgY29uc3QgYm9va0lkID0gYm9vay5rZXkuc3RhcnRzV2l0aCgnLycpID8gYm9vay5rZXkuc2xpY2UoMSkgOiBib29rLmtleTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6IGJvb2tJZCxcclxuICAgICAgdGl0bGU6IGJvb2sudGl0bGUsXHJcbiAgICAgIGF1dGhvcjogYm9vay5hdXRob3JfbmFtZT8uWzBdIHx8IFwiVW5rbm93biBBdXRob3JcIixcclxuICAgICAgYXV0aG9yczogYm9vay5hdXRob3JfbmFtZSB8fCBbXSxcclxuICAgICAgY292ZXI6IGJvb2suY292ZXJfaVxyXG4gICAgICAgID8gdGhpcy5nZXRDb3ZlclVybChib29rLmNvdmVyX2kpXHJcbiAgICAgICAgOiBcIi9wbGFjZWhvbGRlci1ib29rLnN2Z1wiLFxyXG4gICAgICBwdWJsaXNoWWVhcjogYm9vay5maXJzdF9wdWJsaXNoX3llYXIsXHJcbiAgICAgIGlzYm46IGJvb2suaXNibj8uWzBdLFxyXG4gICAgICByYXRpbmc6IGJvb2sucmF0aW5nc19hdmVyYWdlLFxyXG4gICAgICByZXZpZXdDb3VudDogYm9vay5yYXRpbmdzX2NvdW50LFxyXG4gICAgICBzdWJqZWN0czogYm9vay5zdWJqZWN0Py5zbGljZSgwLCA1KSB8fCBbXSxcclxuICAgICAgcHVibGlzaGVyczogYm9vay5wdWJsaXNoZXIgfHwgW10sXHJcbiAgICAgIGxhbmd1YWdlczogYm9vay5sYW5ndWFnZSB8fCBbXSxcclxuICAgICAgd2FudFRvUmVhZENvdW50OiBib29rLndhbnRfdG9fcmVhZF9jb3VudCxcclxuICAgICAgY3VycmVudGx5UmVhZGluZ0NvdW50OiBib29rLmN1cnJlbnRseV9yZWFkaW5nX2NvdW50LFxyXG4gICAgICBhbHJlYWR5UmVhZENvdW50OiBib29rLmFscmVhZHlfcmVhZF9jb3VudCxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcblxyXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gZGVib3VuY2Ugc2VhcmNoIHJlcXVlc3RzXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxyXG4gIGZ1bmM6IFQsXHJcbiAgd2FpdDogbnVtYmVyXHJcbik6ICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB2b2lkIHtcclxuICBsZXQgdGltZW91dDogTm9kZUpTLlRpbWVvdXQ7XHJcbiAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XHJcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBmdW5jKC4uLmFyZ3MpLCB3YWl0KTtcclxuICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJPUEVOX0xJQlJBUllfQkFTRV9VUkwiLCJDT1ZFUlNfQkFTRV9VUkwiLCJPcGVuTGlicmFyeUFQSSIsInNlYXJjaEJvb2tzIiwicXVlcnkiLCJsaW1pdCIsIm9mZnNldCIsInNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInEiLCJ0b1N0cmluZyIsImZpZWxkcyIsInJlc3BvbnNlIiwiZmV0Y2giLCJvayIsIkVycm9yIiwic3RhdHVzVGV4dCIsImpzb24iLCJnZXRCb29rRGV0YWlscyIsImJvb2tLZXkiLCJnZXRBdXRob3JEZXRhaWxzIiwiYXV0aG9yS2V5IiwiZ2V0Q292ZXJVcmwiLCJjb3ZlcklkIiwic2l6ZSIsInNlYXJjaEJ5R2VucmUiLCJnZW5yZSIsInNlYXJjaEJ5QXV0aG9yIiwiYXV0aG9yIiwic2VhcmNoQnlJU0JOIiwiaXNibiIsImdldFRyZW5kaW5nQm9va3MiLCJnZXRQb3B1bGFyQm9va3NCeUdlbnJlIiwic29ydCIsImZvcm1hdEJvb2tEYXRhIiwiYm9vayIsImJvb2tJZCIsImtleSIsInN0YXJ0c1dpdGgiLCJzbGljZSIsImlkIiwidGl0bGUiLCJhdXRob3JfbmFtZSIsImF1dGhvcnMiLCJjb3ZlciIsImNvdmVyX2kiLCJwdWJsaXNoWWVhciIsImZpcnN0X3B1Ymxpc2hfeWVhciIsInJhdGluZyIsInJhdGluZ3NfYXZlcmFnZSIsInJldmlld0NvdW50IiwicmF0aW5nc19jb3VudCIsInN1YmplY3RzIiwic3ViamVjdCIsInB1Ymxpc2hlcnMiLCJwdWJsaXNoZXIiLCJsYW5ndWFnZXMiLCJsYW5ndWFnZSIsIndhbnRUb1JlYWRDb3VudCIsIndhbnRfdG9fcmVhZF9jb3VudCIsImN1cnJlbnRseVJlYWRpbmdDb3VudCIsImN1cnJlbnRseV9yZWFkaW5nX2NvdW50IiwiYWxyZWFkeVJlYWRDb3VudCIsImFscmVhZHlfcmVhZF9jb3VudCIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJ0aW1lb3V0IiwiYXJncyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/openLibrary.ts\n"));

/***/ })

});